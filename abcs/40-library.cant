;; Using modules and loading source files

(let library-path "/home/parallels/g/cant/library/")
;; TODO the fully-qualified names get absurdly long, what to do?
;; TODO set library-path at install time

(to (path-for-use base-path file-stem)
  (if (symbol? file-stem)
      (chain library-path file-stem.name)
      (normalize-path base-path file-stem)))

(to (normalize-path base-path file-stem)
  (if (path-absolute? file-stem)
      file-stem
      (do (let foo (path-join base-path file-stem))
;          (unless (= foo file-stem)
;            (out .say "was ~w, gonna be ~w\n" file-stem foo))
          foo)))
;          file-stem)))

(to (path-join base-path file-stem)
  (chain base-path "/" file-stem))      ;TODO not normalized

(let the-modules (!map<-))
(let use-base-path (box<- (current-directory)))

;; To make it possible to reload a module by calling (use file-stem)
;; again afterward. N.B. that won't mutate the existing module object.
(to (unuse file-stem)                   ;TODO better name
  (the-modules .delete! file-stem))

(to (use file-stem)                  ;TODO a realer module system
  (let stem (if (symbol? file-stem)
                (path-join library-path file-stem.name)
                (normalize-path use-base-path.^ file-stem)))
  (or (the-modules .get stem)
      (with-use-path (path-parent stem)
                     (: (hey (load-module (chain stem ".cant") `(,stem))
                             (-> (the-modules .set! stem it)))))))

(to (with-use-path path thunk)
  (let old-base-path use-base-path.^)
  (use-base-path .^= path)
  (ejector-protect
   thunk
   (: (use-base-path .^= old-base-path))))

;; TODO relative loading like (use filename), I guess
(to (load filename @(optional context))
  (let exp `(do ,@(with-input-file read-all filename)))
  (with-use-path (path-parent filename)
                 (: (cant .play exp main-interactive-setting context))))

(to (load-module filename @(optional context))
  (let exp `(hide ,@(with-input-file read-all filename)))
  (let setting full-powered-setting)
;;  (let setting computational-setting)  ;TODO
  (cant .play exp setting context))

(let full-powered-setting-extra-names
  '(full-powered-setting use
    nano-now nanosleep out stdin os-exit
    extract-datum extract-script
    open-input-file open-output-file with-input-file with-output-file
    system/must-succeed
    the-modules unuse load load-module
    the-last-error push-signal-handler with-signal-handler the-signal-handler
    unwind-protect ;;TODO I guess for computational-setting if we're to have it at all
    listener<- debug breakpoint))
(let full-powered-setting ;XXX
  (empty-setting .extend-promises
                 (chain full-powered-setting-extra-names
                        computational-setting-library-imports
                        computational-setting-names)))
(full-powered-setting .resolve-each! primordial-setting computational-setting-names)

(let main-interactive-setting full-powered-setting.extend-mutable)
(cant .play `(let main-interactive-setting ',main-interactive-setting)
            main-interactive-setting)
