;; Using modules and loading source files

(let the-modules (!map<-))

;; To make it possible to reload a module by calling (use file-stem)
;; again afterward. N.B. that won't mutate the existing module object.
(to (unuse file-stem)                   ;TODO better name
  (the-modules .delete! file-stem))

(to (use file-stem)                  ;TODO a realer module system
  ;; N.B. could sort of just use memoize if that were already loaded.
  (let stem (if (symbol? file-stem)
                (chain "library/" file-stem.name)
                file-stem))
  (or (the-modules .get stem)
      (hey (load-module (chain stem ".cant") `(,stem))
           (-> (the-modules .set! stem it)))))

(to (load filename @(optional context))
  (let exp `(do ,@(with-input-file read-all filename)))
  (cant .play exp main-interactive-setting context))

(to (load-module filename @(optional context))
  ;; TODO the 'let' is a hack
  (let exp `(hide (let use ',use) ,@(with-input-file read-all filename)))
  ;;TODO reduce to computational-setting
  (let setting full-powered-setting)
  (cant .play exp setting context))

(let full-powered-setting-extra-names
  '(full-powered-setting
    main-interactive-setting          ;XXX
    nano-now nanosleep out stdin read os-exit
    extract-datum extract-script
    newline write print displayln with-input-file with-output-file
    system/must-succeed
    the-modules unuse load load-module
    the-last-error push-signal-handler with-signal-handler the-signal-handler
    unwind-protect                      ;XXX used?
    listener<- debug breakpoint
    display))
(let full-powered-setting ;XXX
  (empty-setting .extend-promises
                 (chain full-powered-setting-extra-names
                        computational-setting-library-imports
                        computational-setting-names)))
(full-powered-setting .resolve-each! primordial-setting computational-setting-names)

(let main-interactive-setting 
  ((full-powered-setting .extend '(load use) [load use])  ;XXX hacky
   .extend-mutable))
