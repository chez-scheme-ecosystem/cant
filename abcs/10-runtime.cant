;; This special source file must be written to load without actually
;; invoking any primitive object, because this code *defines* their
;; scripts. Only after this file is loaded will the definitions get
;; magically connected to the primitives.

;; That works out because the top level here is just definitions, with
;; no top-level actions.

;; There's also a definition of map<-, needed to implement (export ...).

;; Aaand this includes further definitions used by the above-needed
;; definitions, transitively.

(make-trait miranda-trait me
  (to (~ .selfie sink) (sink .display (__depict me)))
  (to message (error "Match failure" me message)))

;; Generic map trait
;; requires:
;;  .get key default
;;  .count -- hm, we could impl as .items.count
;;  .items

;; TODO untested, unused yet
;; TODO mutable-map trait?

;(make missing)
;; Problem: (map .get key missing) might save `missing` for later.
;; For now, we'll make a new `missing` every time, though that's
;; uglyish and kinda expensive.

(make-trait map-trait map
  (to (~ key)
    (make missing)
    (let answer (map .get key missing))
    (if (= answer missing)
        (error "Missing key" map key)
        answer))
  (to (~ .get key)
    (map .get key #no))
  (to (~ .maps? key)
    (make missing)
    (not= (map .get key missing) missing))
  (to ~.none?  (= map.count 0))  ; or map.items.none? - is that better? depends.
  (to ~.some?  (not map.none?))
  (to ~.keys   (each (~ .part 0) map.items))
  (to ~.values (each (~ .part 1) map.items))
  (to (~ .find? value)
    (map.values .find? value))
  (to (~ .find value default)
    (begin searching ((items map.items))
      (if items.none?
          default
          (may items.first
            (be (~ k v) (if (= v value) k (searching items.rest)))
            (else (searching items.rest))))))
  (to (~ .find value)
    (make missing)
    (let key (map .find value missing))
    (when (= key missing)
      (error "Missing value" value))
    key)
  (to ~.copy ;TODO rename .diverge; check that all uses want a !map result
    (!map<-items map.items))
  (to (~ .intersects? map2)
    ;; TODO: maybe iterate over the one with smaller .count ?
    (for some ((k map.keys))
      (map2 .maps? k)))
  (to (~ .disjoint? map2)                    ;too trivial?
    (not (map .intersects? map2)))
  (to ~.domain
    (set<-list map.keys))   ;TODO usually worth specializing
  (to ~.range
    (set<-list map.values))
  (to ~.inverse
    (let inverse (!map<-))
    (for each! (((~ k v) map.items))
      (when (inverse .maps? v)
        (error ".inverse of noninvertible map" map))  ; or just allow it?
      (inverse .set! v k))
    inverse)

  ;; What's the right definition & interface for these for maps?
  ;; TODO also, rename to .or, .and ?
  (to (~ .union other)
    (error "unimplemented .union"))
  (to (~ .intersect other)                 
    (error "unimplemented .intersect"))
  (to (~ .difference other)
    (error "unimplemented .difference"))

;;  (to (~ .compare xs)
;;  (to (~ .slice keys)
  )

(make-trait list-trait list
  (to (~ i)
    (may i
      (be 0 list.first)
      (else (list.rest i.-))))
  (to ~.none?
    (= 0 list.count)) ;N.B. these default implementations are circular
  (to ~.first
    (list 0))
  (to ~.rest
    (list .slice 1))
  (to ~.count
    ;; TODO non-tail-recursive would be more OO in style. Go back to that?
    (begin counting ((remainder list) (count 0))
      (if remainder.none?
          count
          (counting remainder.rest count.+))))
  (to (~ .slice i)
    (surely (<= 0 i))
    (hm (if (= i 0) list)
        (if list.none? list)
        (else (list.rest .slice i.-))))
  (to (~ .slice i bound)     ;XXX result is a link-list; be more generic?
    (surely (<= 0 i))
    (hm (if list.none? list)
        (if (<= bound i) '())
        (if (= i 0) (link list.first (list.rest .slice 0 bound.-)))
        (else (list.rest .slice i.- bound.-))))
  (to (~ .chain seq)                         ;TODO self if seq is ()
    (if list.none?
        seq
        (link list.first (list.rest .chain seq))))
  (to (~ .compare xs)
    ;; N.B. mutable arrays compare by this method, so it's really a comparison as of right now
    (hm (if list.none? (if xs.none? 0 -1))
        (if xs.none? 1)
        (else (may (list.first .compare xs.first)
                (be 0 (list.rest .compare xs.rest))
                (be d d)))))
  ;; A sequence is a kind of collection. Start implementing that:
  (to ~.keys
    (0 .to< list.count)) ;TODO move this impl to array-trait; here, enum lazily.
  (to ~.values
    list)
  (to ~.items
    (enumerate list))
  (to (~ .get key default)
    (if (count? key)
        (begin walking ((k key) (xs list))
          (hm (if xs.none? default)
              (if (= k 0) xs.first)
              (else (walking k.- xs.rest))))
        default))
  (to (~ .maps? key)
    (and list.some?
         (or (= 0 key)
             (and (< 0 key)
                  (list.rest .maps? key.-)))))
  (to (~ .find value default)    ;; XXX update the other collections to have this too
    (begin looking ((i 0) (values list))
      (hm (if values.none? default)
          (if (= value values.first) i)
          (else (looking i.+ values.rest)))))
  (to (~ .find value)
    (may (list .find value #no)
      (be #no (error "Missing value" value))
      (be key key)))
  (to (~ .find? value)
    (may (list .find value #no)
      (be #no #no)
      (else   #yes)))
  (to (~ .last)
    (let rest list.rest)
    (if rest.none? list.first rest.last))
  (to (~ .prefix? p)
    (= (list .slice 0 p.count) p))   ;TODO more efficient
  (to (~ .repeat n)
    ;;TODO a method to get an empty seq of my type; and then factor out duplicate code
    (may n
      (be 0 '())             
      (else (chain @(for each ((_ (0 .to< n)))
                      list)))))
  (to ~.maybe  ;; TODO an experiment TODO could be defined on maps in general too
    (if list.none?
        #no
        (do (unless list.rest.none?
              (error "Tried to convert to maybe from count >1" list))
            list.first)))
  (to ~.only  ;; TODO an experiment TODO could be defined on maps in general too
    (when list.none?
      (error "Tried to .only from empty" list))
    (unless list.rest.none?
      (error "Tried to .only from count >1" list))
    list.first)
  (to message
    (map-trait list message)))

(make-trait claim-primitive me
  (to ~.count       (if me 1 0))
  (to (~ .selfie sink) (sink .display (if me "#yes" "#no")))
  (to (~ .compare a)
    (may a
      (be #no  (if me 1 0))
      (be #yes (if me 0 -1))
      (else #no)))
  )

(make-trait procedure-primitive me
  )

(make-trait number-primitive me
  (to (~ .+ a)         (__+ me a))
  (to (~ .- a)         (__- me a))
  (to (~ .* a)         (__* me a))
  (to (~ .compare a)   (__number-compare me a))
  (to (~ .quotient b)  (__quotient me b))
  (to (~ .remainder b) (__remainder me b))
  (to (~ .modulo b)    (__modulo me b))
  (to (~ .*/mod m d)   (__*/mod me m d))
  (to (~ ./mod d)      (__*/mod me 1 d))
  (to (~ .<< b)        (__bit-<<  me b))
  (to (~ .>> b)        (__bit->>  me b))
  (to ~.not            (__bit-not me))
  (to (~ .and b)       (__bit-and me b))
  (to (~ .or b)        (__bit-or  me b))
  (to (~ .xor b)       (__bit-xor me b))
  (to (~ .to< b)       (interval<- me b))
  (to (~ .to b)        (interval<- me b.+))
  (to (~ .span n)      (interval<- me (+ me n)))
  (to ~.even?          (surely (integer? me)) (= 0 (me .modulo 2)))
  (to ~.odd?           (surely (integer? me)) (not= 0 (me .modulo 2)))
  (to (~ .divides? b)  (surely (integer? me)) (= 0 (b .modulo me)))
  (to ~.+              (__+ me 1))      ;experiment
  (to ~.-              (__- me 1))      ;experiment
  ;; XXX sketchy support for 32-bit word ops:
  (to (~ .u+ a)        (__u+ me a))
  (to (~ .u- a)        (__u- me a))
  (to (~ .u/ a)        (__u/ me a))
  (to (~ .u>> a)       (__u>> me a))
  (to (~ .u<< a)       (__u<< me a))
  (to (~ .s+ a)        (__s+ me a))
  (to (~ .s* a)        (__s* me a))
  )

(make-trait symbol-primitive me
  (to ~.name           (__symbol->string me))
  (to (~ .compare a)   (and (symbol? a)
                            (me.name .compare a.name)))
  (to (~ .selfie sink) (sink .display me.name))
  ;; TODO experiment:
  (to ~.term<-         (on (@arguments) (term<- me arguments)))
  (to ~.term           (term<- me '()))
  (to ~.method         (on (actor @arguments) ;TODO experiment; vs. method<- in stdlib
                         (call actor (term<- me arguments))))
  ;; Some silly conveniences for sturm:
  (to ~.lowercase      (symbol<- me.name.lowercase))
  (to ~.uppercase      (symbol<- me.name.uppercase))
  )

(make-trait nil-primitive me
  (to ~.none?          #yes)
  (to ~.first          (error "Empty list" '.first))
  (to ~.rest           (error "Empty list" '.rest))
  (to ~.count          0)
  (to (~ i)            (error "Empty list" 'nth i))
  (to (~ .chain a)     a)
  (to (~ .selfie sink) (sink .display "()"))
  (to message          (list-trait me message))) ;XXX use trait syntax instead

(make-trait link-primitive me
  (to ~.none?       #no)
  (to ~.first       (__car me))
  (to ~.rest        (__cdr me))
  (to ~.count       (__length me))
  (to (~ i)         (__list-ref me i))    ;XXX just use the trait method? then can e.g. mix lazy and eager list nodes
  (to (~ .chain a)  (__append me a)) ;TODO fall back to list-trait if a is not a list
  (to (~ .selfie sink)
    (may me
      (be `(quote ,x)
        (sink .display "'")
        (sink .write x))
      (else
       (sink .display "(")
       (sink .write me.first)
       (begin printing ((r me.rest))
         (hm (when (link? r)
               (sink .display " ")
               (sink .write r.first)
               (printing r.rest))
             (when (null? r) 'ok)
             (else
               (sink .display " . ")       ;XXX we're not supporting this in read, iirc
               (sink .write r))))
       (sink .display ")"))))
  (to message
    (list-trait me message))) ;XXX use trait syntax instead

(make-trait array-trait me
  (to (~ .slice i)
    (me .slice i me.count))
  (to (~ .slice i bound)                     ;XXX untested
    (let v (array<-count (- bound i)))
    (v .move! 0 me i bound)
    v)
  (to ~.last
    (me me.count.-))
  (to (~ .copy! v)
    (me .move! 0 v 0 v.count))
  (to (~ .move! dst source lo bound)
    ;; TODO no-op if in range and (me,dst) == (source,lo)
    (let lo->dst (- dst lo))
    (for each! ((i (if (<= dst lo)
                       (interval<- lo bound)
                       (interval<- bound.- lo -1))))
      (me .set! (+ i lo->dst)
          (source i))))
  (to ~.values
    (each me (interval<- 0 me.count)))   ;TODO cheaper to represent by self -- when can we get away with that?
  (to ~.items
    (for each ((i (interval<- 0 me.count)))
      (~ i (me i))))
  (to (~ .get key default)
    (hm (unless (count? key) default)
        (if (<= me.count key) default)
        (else (me key))))
  (to (~ .swap! i j)
    (let t (me i))
    (me .set! i (me j))
    (me .set! j t))
  (to message
    (list-trait me message))) ;XXX use trait syntax instead

(make-trait array-primitive me
  (to ~.none?         (= 0 me.count))   ;redundant definition(s) for speed
  (to ~.first         (me 0))
  (to ~.rest          (me .slice 1))
  (to (~ .set! i val) (__vector-set! me i val))
  (to ~.count         (__vector-length me))
  (to (~ i)           (__vector-ref me i))
  (to (~ .maps? i)    (__vector-maps? me i))
  (to (~ .chain v)    (__vector-append me v))
  (to ~.values        (__vector->list me))
  (to (~ .slice i)    (__subvector me i me.count))
  (to (~ .slice i j)  (__subvector me i j))
  (to (and (~ .move! dst source lo bound)
           message)
    ;; Block-copy source[lo..bound) to me[dst..dst+(bound-lo)).
    (if (array? source)
        (__vector-move! me dst source lo bound)
        (array-trait me message)))
  (to ~.copy          (__vector-copy me))
  (to (~ .update key f)         ;TODO define in a mutable-map-trait ?
    (let value (f (me key)))
    (me .set! key value)
    value)
  (to (~ .selfie sink)
    (sink .display "[")
    (when (< 0 me.count)
      (sink .write (me 0))
      (for each! ((x ((__vector->list me) .rest)))
        (sink .display #\space)
        (sink .write x)))
    (sink .display "]"))
;   (sink .write (__vector->list me)))
  (to message
    (array-trait me message))) ;XXX use trait syntax instead

(make-trait string-primitive me
  (to ~.none?        (= 0 me.count))
  (to ~.first        (me 0))
  (to ~.rest         (me .slice 1))
  (to ~.count        (__string-length me))
  (to (~ i)          (__string-ref me i))
  (to (~ .maps? i)   (__string-maps? me i))
  (to (~ .chain s)   (__string-append me s))
  (to (~ .slice i)   (__substring me i me.count))
  (to (~ .slice i j) (__substring me i j))
  (to (~ .compare s)
    (if (string? s)
        (__string-compare me s)          ; just a speedup
        (list-trait me (~ .compare s))))   ; but is this what we really want? (<=> "a" '(#\a))
  (to (~ .join ss)   ;should this be a function, not a method?
    (if ss.none?
        ""
        ;; De-quadratified (foldr1 (on (x y) (chain x me y)) ss)
        (do (let mine me.values)
            (string<-list (foldr1 (on (s chars)
                                    (s.values .chain (mine .chain chars.values)))
                                  ss)))))
  (to ~.values       (list<-string me))
  (to (~ .get key)   (me .get key #no)) ;TODO duplicated because delegation is slow
  (to (~ .get key default)      ;TODO could be shared with array-trait
    (if (me .maps? key)
        (me key)
        default))
  (to (~ .trim-left)
    (let limit me.count)
    (begin scanning ((i 0))
      (hm (when (= i limit)
            "")
          (do (let c (me i)))
          (unless c.whitespace?
            (me .slice i))
          (else (scanning i.+)))))
  (to ~.trim-right
    (begin scanning ((i me.count))
      (hm (when (= i 0)
            "")
          (do (let c (me i.-)))
          (unless c.whitespace?
            (me .slice 0 i))
          (else (scanning i.-)))))
  (to ~.trim
    me.trim-left.trim-right)
  (to ~.split
    ;; TODO dequadratify
    (begin splitting ((s me.trim-left))
      (if s.none?
          '()
          (do (let limit s.count)
              (begin scanning ((i 1))
                (hm (if (= i limit) `(,s))
                    (if ((s i) .whitespace?)
                        (link (s .slice 0 i)
                              (splitting ((s .slice i.+) .trim-left))))
                    (else (scanning i.+))))))))
  (to (~ .split delimiter)
    ;; TODO deduplicate code
    ;; TODO define a strstr and use that
    (if me.none?
        '()
        (begin splitting ((s me))
          (if s.none?
              '("")
              (do (let limit s.count)
                  (begin scanning ((i 0))
                    (hm (if (= i limit) `(,s))
                        (if (= delimiter (s .slice i (+ i delimiter.count)))
                            (link (s .slice 0 i)
                                  (splitting (s .slice (+ i delimiter.count)))))
                        (else (scanning i.+)))))))))
  (to ~.lowercase (string<-list (each ~.lowercase me)))
  (to ~.uppercase (string<-list (each ~.uppercase me)))
  (to ~.capitalize (chain ((me .slice 0 1) .uppercase) (me .slice 1)))
  (to (~ .replace pattern replacement) ;TODO more efficient
    ;; TODO unify the cases?
    (hm (if pattern.none?
            (for foldr ((ch me) (rest replacement))
              (chain replacement (string<- ch) rest)))
        (else
         (let limit me.count)
         (string<-list
          ;; TODO define a strstr and use that
          (begin scanning ((i 0))
            (hm (if (= i limit) '())
                (if (= pattern (me .slice i (+ i pattern.count)))
                    (chain (list<-string replacement)
                           (scanning (+ i pattern.count))))
                (else (link (me i) (scanning i.+)))))))))
  (to (~ .justify n)
    (me .justify n #\space))
  (to (~ .justify n pad)
    (if (< n 0)
        (me .left-justify (- n) pad)
        (me .right-justify n    pad)))
  (to (~ .left-justify n)
    (me .left-justify n #\space))
  (to (~ .left-justify n pad-char)
    (let pad (- n me.count))
    (if (<= pad 0)
        me
        (chain me ((string<- pad-char) .repeat pad))))
  (to (~ .right-justify n)
    (me .right-justify n #\space))
  (to (~ .right-justify n pad-char)
    (let pad (- n me.count))
    (if (<= pad 0)
        me
        (chain ((string<- pad-char) .repeat pad) me)))
  (to (~ .center n)
    (let pad (- n me.count))
    (if (<= pad 0)
        me
        (do (let half (pad .quotient 2))
            (chain (" " .repeat (- pad half))
                   me
                   (" " .repeat half)))))
  (to (~ .repeat n)
    ("" .join (each (-> me) (interval<- 0 n))))
  (to (~ .format @arguments)
    (string<-writer (-> (format .to-sink it me @arguments))))
  (to ~.split-lines
    ;; TODO ugly. This 'if' is needed because we want a final "\n" to
    ;; yield the same output as a string with no final "\n". N.B. while
    ;; that's convenient it's also information-destroying.
    (let tweaked (if (and me.some? (= me.last #\newline))
                     (me .slice 0 me.count.-)
                     me))
    ;; TODO it'd be nice for efficiency if tweaked could be a view instead of a copy
    (tweaked .split "\n"))
  (to (~ .selfie sink)
    (sink .display #\")
    (for each! ((c me))
      (sink .display (may c            ;XXX super slow. We might prefer to use the Scheme built-in.
                       (be #\\ "\\\\")
                       (be #\" "\\\"")
                       (be #\newline "\\n")
                       (be #\tab     "\\t")
                       (be #\return  "\\r")
                       ;; XXX escape the control chars
                       (else c))))
    (sink .display #\"))
  (to message
    (list-trait me message))) ;XXX use trait syntax instead

(make-trait char-primitive me
  (to ~.code          (__char->integer me))
  (to ~.letter?       (__char-letter? me))
  (to ~.digit?        (__char-digit? me))
  (to ~.whitespace?   (__char-whitespace? me))
  (to ~.alphanumeric? (or me.letter? me.digit?))
  (to ~.lowercase?    (__char-lowercase? me))
  (to ~.uppercase?    (__char-uppercase? me))
  (to ~.lowercase     (__char-lowercase me))
  (to ~.uppercase     (__char-uppercase me))
  (to ~.printable?    (<= 32 (__char->integer me) 126))  ; TODO better name?
  (to (~ .compare c)  (__char-compare me c))
  (to (~ .+ n)   ;; Is this a good idea?
    (surely (integer? n) "Bad arg type" n)
    (char<- (+ me.code n)))
  (to (~ .- b)
    (may b
      (be (? integer?) (char<- (- me.code b)))
      (be (? char?)    (- me.code b.code))
      (else (error "Bad arg type" b))))
  (to (~ .to< b)      (interval<- me b))       ;These methods should be in a trait
  (to (~ .to b)       (interval<- me b.+))    ;if they're a good idea at all...
  (to (~ .span n)     (interval<- me (+ me n)))
  (to ~.+             (me .+ 1))      ;experiment
  (to ~.-             (me .- 1))      ;experiment
  )

;; TODO: should a box be a collection?
(make-trait box-primitive me
  (to ~.^             (__box-value me))
  (to (~ .^= val)     (__box-value-set! me val))
  (to (~ .update f) ;TODO better name? I left out the '!' to emphasize it returns the value
    (let value (f me.^))
    (me .^= value)
    value)                              ;TODO return void instead?
  (to (~ .selfie sink)
    (sink .display "<box ")
    (sink .write me.^)
    (sink .display ">"))
  )

(make-trait source-primitive me
  (to ~.read-char   (__read-char me))
  (to ~.read-u8     (__get-u8 me))
  (to ~.read-all    (__read-all me))
  (to ~.close       (__close-port me))
  (to ~.ready?      (__char-ready? me))
  (to ~.read-line
    (let ch me.read-char)
    (if (eof? ch)
        ch
        (string<-list
         (begin reading ((ch ch))
           (if (or (eof? ch) (= ch #\newline))
               '()
               (link ch (reading me.read-char)))))))
  (to ~.read-lines
    me.read-all.split-lines)  ;; TODO inefficient. also, maybe include the newlines?
  )

(make-trait sink-primitive me
  (to (~ .display a)   (unless (__display a me) (me .write a))) ; TODO is this dangerous? longer-term, design the whole display/write thing differently
  (to (~ .write-u8 u8) (__put-u8 me u8))
  (to (~ .write a)     (a .selfie me))
  (to ~.close          (__close-port me))
  (to ~.output-string                 ;XXX for string-sink only
    (__get-output-string me))
  )

(make-trait term-primitive me
  (to (~ receiver)     (call receiver me))
  (to ~.tag            (__term-tag me))
  (to ~.parts          (__term-parts me))
  (to (~ .part n)      ((__term-parts me) n))
  (to (~ .selfie sink)
    (sink .display "{")
    (sink .write me.tag)
    (for each! ((arg me.parts))
      (sink .display " ")
      (sink .write arg))
    (sink .display "}"))
  (to (~ .compare t)
    ((link me.tag me.parts) .compare (link t.tag t.parts)))
  )

(make-trait void-primitive me
  ;; A Scheme type returned by some of the Scheme operations.
  )

(make-trait eof-primitive me
  ;; The eof object.
  )

(make-trait script-primitive me
  (to ~.name    (__script-name me))
  (to ~.trait   (__script-trait me))
  (to ~.clauses (__script-clauses me))
  (to (~ .selfie sink)
    (sink .display "<script ")
    (sink .display me.name)
    (sink .display ">"))
  )

(make-trait cps-primitive me
  (to (~ .selfie sink)
    (sink .display "#<primitive ")
    (sink .display (__cps-primitive-name me))
    (sink .display ">"))
  )

(make-trait ejector-primitive me
  (to (~ .eject value)
    (__eject me value))
  (to (~ .selfie sink)
    (sink .display "#<ejector>"))       ;TODO show enabledness
  )


;; Immutable maps, placeholder implementation
;; N.B. (export foo bar) gets expanded into code like
;;   (map<- (~ 'foo foo) (~ 'bar bar))
;; (but hygienic, when I get to fixing the current bad hygiene).

(make-trait map-primitive map
  (to (~ key)
    (may (__mapi-get key map)
      (be #no (error "Missing key" map key))
      (be (~ _ v) v)))
  (to (~ .get key @(optional default))
    (may (__mapi-get key map)
      (be #no default)
      (be (~ _ v) v)))
  (to (~ .maps? key)
    (not (not (__mapi-get key map))))
  (to ~.none?
    (null? (__mapi-items map)))
  (to ~.items
    (__mapi-items map))
  (to ~.count
    (~.count (__mapi-items map))) ;TODO move to map-trait
  (to (~ .override other-map) ;TODO name; TODO efficient impl; TODO find where it's used
    (map<-items (chain map.items other-map.items)))
  (to (~ .selfie sink)
    (sink .display "#<map")
    (for each! ((key map.keys))
      (sink .display #\space)
      (sink .write key))
    (sink .display ">"))
  (to message
    (map-trait map message)))

(to (map<- @items)
  (map<-items items))

(to (map<-lists lists)
  (map<-items (each tuple<-list lists)))

(to (tuple<-list xs)
  (term<- '~ (as-list xs)))


;; XXX especially temporary defs
(make-trait setting-primitive setting
  (to (~ variable)                      ;TODO different name?
    (__setting-lookup (__setting-a-list setting) variable))
  (to (~ .resolve! variable value)
    (__setting-resolve! (__setting-a-list setting) variable value))
  (to (~ .extend variables values)
    (__setting<- (chain (each list<- variables values)
                        (__setting-a-list setting))))
  (to (~ .extend-promises variables)
    (__setting<- (__setting-extend-promises (__setting-a-list setting)
                                            variables)))
  (to (~ .binds? variable)
    ;; TODO what's the answer for a not-yet-resolved variable?
    (or (yeah? (assoc variable (__setting-a-list setting)))
        (global-defined? variable)))
  (to ~.variables
    ;; TODO a .really-all-the-variables including the globals
    (each ~.first (__setting-a-list setting)))
  )

(to (yeah? x)
  (not (not x)))


;; I think quasiquote currently expands into calls to this sometimes  TODO checkme
(to (list<- @arguments)
  arguments)


;; Hash-maps

;; TODO:
;;   extend map-trait
;;   test deletion more
;;   nonlinear probing -- now quadratic, but how about xor probing?
;;   preserving insertion order
;;   immutable snapshots
;;
;;   impl without a million boxes
;;   N.B. impl needs shared closures for efficiency
;;        (capacity, occupants, ..., hashmap)
;;   special-case impls for small maps and common-typed maps
;;   store hash codes instead of recomputing?
;;   etc.

(let !map<-
  (hide

    (make none)
    (make deleted)

    (make !map<-

      (to (~)
        (let count (box<- 0))
        (let keys  (box<- [none]))  ;; size a power of 2
        (let vals  (box<- [#no]))   ;; same size

       ;; temp performance tracking
;;       (let n-places (box<- 0))
;;       (let n-probes (box<- 0))

        (to (capacity) keys.^.count)

        (to (occupants)
          (begin walking ((i (- (capacity) 1)))
            (hm (if (< i 0)       '())
                (do (let k (keys.^ i)))
                (if (= k none)    (walking i.-))
                (if (= k deleted) (walking i.-))
                (else             (link i (walking i.-))))))

        (to (place key)
          (__place key keys.^ none deleted))

        (to (maybe-grow)
          (when (< (* 2 (capacity))
                   (* 3 count.^))
            (resize (* 2 (capacity)))))

        (to (resize new-capacity)
;;         (print `(resize ,new-capacity places ,n-places.^ probes ,n-probes.^
;;                         average ,(inexact<-exact (/ n-probes.^ (max 1 n-places.^)))))
;;         (n-places .^= 0)
;;         (n-probes .^= 0)
          (let old-keys keys.^)
          (let old-vals vals.^)
          (keys .^= (array<-count new-capacity none))
          (vals .^= (array<-count new-capacity))
          (for each! (((~ i key) old-keys.items))
            (unless (or (= key none) (= key deleted))
              (let {missing-at j} (place key))
              (keys.^ .set! j key)
              (vals.^ .set! j (old-vals i)))))
       
        (make !map {extending map-trait}
          (to (~ key)
            (may (place key)
              (be {at i} (vals.^ i))
              (else      (error "Missing key" !map key))))
          (to (~ .get key @(optional default))
            (may (place key)
              (be {at i} (vals.^ i))
              (else      default)))
          (to (~ .set! key val)
            (may (place key)
              (be {at i}
                (vals.^ .set! i val))
              (be {missing-at i}
                (keys.^ .set! i key)
                (vals.^ .set! i val)
                (count .^= count.^.+)
                (maybe-grow))))
          (to (~ .maps? key)
            (may (place key)
              (be {at _} #yes)
              (else      #no)))
          (to ~.none? (= count.^ 0))
          (to ~.count  count.^)
          (to ~.keys   (each keys.^ (occupants))) ;XXX lazy-map
          (to ~.values (each vals.^ (occupants)))
          (to ~.items
            (let ks keys.^)
            (let vs vals.^)
            (for each ((i (occupants)))
              (~ (ks i) (vs i))))
          (to (~ .get-set! key value<-)
            (may (place key)
              (be {at i}
                (vals.^ i))
              (be {missing-at _}
                (let value (value<-))
                ;; Alas, we can't just stick it in at i because (value<-)
                ;; might have changed things too:
                (!map .set! key value)
                value)))
          (to (~ .delete! key)
            (may (place key)
              (be {at i}
                (keys.^ .set! i deleted)
                (count .^= count.^.-)
                #no)
              (else #no)))   ;XXX error instead? It is in Python.
          (to (~ .find? value)
            (!map.values .find? value))
          (to (~ .find value default)
            (let vs vals.^)
            (begin searching ((js (occupants)))  ;XXX should be lazy
              (hm (if js.none? default)
                  (if (= value (vs js.first)) (keys.^ js.first))
                  (else (searching js.rest)))))
          (to ~.clear!
            (count .^= 0)
            (keys .^= [none])
            (vals .^= [#no]))
          (to ~.copy
            (!map<-items !map.items))
          (to (~ .update key f)         ;TODO define in a mutable-map-trait ?
            (let value (f (!map key)))  ;TODO what about a (!map .get key) version? how to factor this?
            (!map .set! key value)
            value)
          (to (~ .selfie sink)
            (sink .display "#<map (")   ;TODO rename !map
            (sink .write count.^)
            (sink .display ")>"))
          ))

      (to (~ @items)
;;        (!map<-items items))
        (let m (!map<-))
        (for each! (((~ k v) items))
          (m .set! k v))
        m)
      )))

(to (!map<-items items)
  (let m (!map<-))
  (for each! (((~ k v) items))
    (m .set! k v))
  m)

(to (!map<-lists lists)
  (let m (!map<-))
  (for each! ((`(,k ,v) lists))
    (m .set! k v))
  m)


;; Sets via hashtable
;; TODO unify with hashmaps

(to (set<- @vals)            ;XXX this name is better saved for frozen sets
  (let s (hash-set<-))
  (s .add-all! vals)
  s)

(to (set<-list vals)            ;XXX this name is better saved for frozen sets
  (let s (hash-set<-))
  (s .add-all! vals)
  s)

(to (hash-set<-)                        ;XXX shouldn't be a global
  (let !map (!map<-)) ;TODO would be nice to avoid storing all the #yes values
  (make set {extending map-trait}
    (to ~.none?            !map.none?)
    (to ~.count            !map.count)
    (to ~.keys             !map.keys)
    (to (~ .maps? key)     (!map .maps? key))
    (to ~.copy             (set<-list !map.keys)) ;TODO tune
    (to (~ .add! key)      (!map .set! key 1))    ;N.B. matching the bag type here
    (to (~ .add-all! vals) (for each! ((v vals)) (set .add! v)))
    (to (~ .union! other)  (set .add-all! other.keys))
    (to (~ .union other)
      (let result set.copy)
      (result .union! other)
      result)
    (to (~ .intersect other)                 ;TODO rename to .and, etc., I guess
      (let result (set<-))
      (for each! ((x !map.keys))
        (when (other .maps? x)
          (result .add! x)))
      result)
    (to (~ .difference other)
      (let result (set<-))
      (for each! ((x !map.keys))
        (unless (other .maps? x)
          (result .add! x)))
      result)
    (to (~ .except other)               ;TODO add to map-trait?
      (let result (set<-))
      (for each! ((x !map.keys))
        (unless (= other x)
          (result .add! x)))
      result)
    (to (~ .intersects? map2)
      (!map .intersects? map2))
    (to ~.clear!         !map.clear!)
    (to (~ .get key)     (!map .maps? key))
    (to (~ key)          (!map .get key 0)) ;I'm not sure this is a good idea, but it's to match the bag type
    (to ~.items          !map.items)
    (to ~.values         !map.values)
    (to (~ .delete! key) (!map .delete! key))
    (to ~.total          !map.count)        ;like bags again
    ;; XXX fill in rest of set interface (just the map interface, I guess)
    (to (~ .selfie sink)
      (sink .display "#<set")
      (sink .write !map.keys)
      (sink .display ">"))
    ))


;; stdlib

(to (surely ok? @arguments)
  (unless ok?
    (error @(if arguments.none? '("Assertion failed") arguments))))

(to (count? x)
  (and (integer? x) (<= 0 x)))

(to (not= x y)
  (not (= x y)))

(make-trait left-folding-operation operation
  (to (~ a b @arguments)
    (foldl operation (operation a b) arguments))
  (to (~ a) a))      ; Of course this no-op by default is overridable.

(make-trait right-folding-operation operation
  (to (~ @arguments)
    (foldr1 operation arguments)))

(make + {extending left-folding-operation}
  (to (~ a b) (a .+ b))
  (to (~) 0))

(make * {extending left-folding-operation}
  (to (~ a b) (a .* b))
  (to (~) 1))

(make - {extending left-folding-operation}
  (to (~ a b) (a .- b))
  (to (~ a) (0 .- a)))

(make-trait transitive-comparison compare?
  (to (~ x @xs)
    (begin comparing ((x0 x) (xs xs))
      (may xs
        (be `()           #yes)
        (be `(,x1 ,@rest) (and (compare? x0 x1)
                               (comparing x1 rest)))))))

(make <   {extending transitive-comparison} (to (~ a b)      (= (compare a b) -1)))
(make <=  {extending transitive-comparison} (to (~ a b) (not (= (compare a b)  1))))
(make <=> {extending transitive-comparison} (to (~ a b)      (= (compare a b)  0))) ; XXX better name?
(make >=  {extending transitive-comparison} (to (~ a b) (not (= (compare a b) -1))))
(make >   {extending transitive-comparison} (to (~ a b)      (= (compare a b)  1)))

(to (compare a b)
  (may (a .compare b)
    (be -1 -1)
    (be  0  0)
    (be +1 +1)
    (else  (error "Incomparable" a b))))

;;XXX so should some of these be in list-trait?

(to (as-list seq)            ;XXX naming convention for coercions?
  (if (list? seq)
      seq
      (begin copying ((seq seq))
        (if seq.none?
            '()
            (link seq.first (copying seq.rest))))))

(to (string<-list chars) (__string<-list (as-list chars)))
(to (array<-list xs)     (__array<-list (as-list xs)))

(make chain {extending right-folding-operation}
  (to (~ xs ys) (xs .chain ys))
  (to (~) '()))

;; Using the optional suffix is like (chain (reverse xs) suffix).
(to (reverse xs @(optional suffix))
  (for foldl ((result (or suffix '()))
              (x xs))
    (link x result)))

(to (foldl f z xs)           ; 'z' connoting zero from f's perspective
  (if xs.none?
      z
      (foldl f (f z xs.first) xs.rest)))

(to (foldr f xs z) ;N.B. some other languages have a different argument order
  (if xs.none?
      z
      (f xs.first (foldr f xs.rest z))))

(to (foldr1 f xs)
  (let tail xs.rest)
  (if tail.none?
      xs.first
      (f xs.first (foldr1 f tail))))

;; TODO: name it (zip @rows) instead, like Python?
(to (transpose rows)
  (if (every ~.none? rows)   ; and make it (some _.none? rows)?
      '()
      `(,(each ~.first rows)
        ,@(transpose (each ~.rest rows)))))

(make-trait zipped-list-transducer transducer
  (to (~ f @lists)
    (for transducer ((args (transpose lists)))
      (f @args)))
  (to message
    (miranda-trait transducer message)))

(make each {extending zipped-list-transducer}
  (to (~ f xs)
    (for foldr ((x xs) (results '()))
      (link (f x) results))))

(make each! {extending zipped-list-transducer}
  (to (~ f xs)
    (unless xs.none?
      (f xs.first)
      (each! f xs.rest))))

(make some {extending zipped-list-transducer}
  (to (~ pass? xs)
    (and xs.some?
         (or (pass? xs.first)
             (some pass? xs.rest)))))

(make every {extending zipped-list-transducer}
  (to (~ pass? xs)
    (or xs.none?
        (and (pass? xs.first)
             (every pass? xs.rest)))))

(make interval<-
  (to (~ first limit)
    (if (<= limit first)
        '()
        (make range {extending list-trait}
          (to ~.none? #no)
          (to ~.first first)
          (to ~.rest  (interval<- first.+ limit))
          (to ~.count (- limit first))
          (to (~ i)
            (if (not (integer? i))
                (error "Key error" range i)
                (do (let j (+ first i))
                    (if (and (<= first j) (< j limit))
                        j
                        (error "Out of range" range i)))))
          (to (~ .maps? i)
            (and (integer? i)
                 (do (let j (+ first i))
                     (and (<= first j) (< j limit)))))
          ;; TODO: .compare
          )))
  (to (~ limit)
    (interval<- 0 limit))
  (to (~ first limit stride)
    ;; TODO factor the code better
    (hm (if (< 0 stride)
            (if (<= limit first)
                '()
                (make range {extending list-trait}
                  (to ~.none? #no)
                  (to ~.first first)
                  (to ~.rest  (interval<- (+ first stride) limit stride))
                  (to (~ i)
                    (error "TODO" range `(,i)))
                  (to (~ .maps? i)
                    (error "TODO" range (~ .maps? i)))
                  )))
        (if (< stride 0)
            (if (< first limit)
                '()
                (make range {extending list-trait}
                  (to ~.none? #no)
                  (to ~.first first)
                  (to ~.rest  (interval<- (+ first stride) limit stride))
                  (to (~ i)
                    (error "TODO" range `(,i)))
                  (to (~ .maps? i)
                    (error "TODO" range (~ .maps? i)))
                  )))
        (else
          (error "Zero stride" first limit stride)))))

(make enumerate
  (to (~ xs)
    (enumerate xs 0))
  (to (~ xs i)
    (if xs.none?
        '()
        (make enumeration {extending list-trait}
          (to ~.none? #no)
          (to ~.first (~ i xs.first))
          (to ~.rest  (enumerate xs.rest i.+))))))

(to (array<- @elements)
  (array<-list elements))

(to (string<- @chars)
  (string<-list chars))

(to (string<-writer take-sink)
  (let sink (string-sink<-))
  (take-sink sink)
  sink.output-string)


;; printf-ish thing. TODO do something completely different?
(let format
  (hide

    (make format
      (to (~ format-string @arguments)
        (scanning out format-string.values arguments))
      (to (~ .to-sink sink format-string @arguments)
        (scanning sink format-string.values arguments)))

    ;;TODO actually design the format language

    (to (scanning sink s args)
      (if s.none? 
          (when args.some?
            (error "Leftover arguments to .format" args))
          (may s.first
            (be #\~
              (parse sink s.rest args))
            (be ch
              (sink .display ch)
              (scanning sink s.rest args)))))

    ;; Parse a ~ field, then go back to scanning the rest of s.
    (to (parse sink s args)
      (let {pair sign s1} (if (s .prefix? '(#\-))
                              {pair -1 s.rest}
                              {pair #no s}))
      (if (s1 .prefix? '(#\0))
          (parsing sink s1.rest #\0     sign 0   args)
          (parsing sink s1      #\space sign #no args)))

    (to (parsing sink s pad sign width args)
      (when s.none?
        (error "Incomplete format")) ;TODO report the format-string
      (may s.first
        (be #\w
          (maybe-pad sink pad sign width (~ .write args.first))
          (scanning sink s.rest args.rest))
        (be #\d
          (maybe-pad sink pad sign width (~ .display args.first))
          (scanning sink s.rest args.rest))
        (be #\~
          (sink .display "~") ;TODO: complain if there were formatting directives before "~"?
          (scanning sink s.rest args))
        (be (? ~.digit? ch)
          (let new-width (+ (- ch #\0)
                            (if width (* 10 width) 0)))
          (parsing sink s.rest pad sign new-width args))
        (be #\x  ; hex number, XXX works wrong on negative numbers
          (maybe-pad sink pad sign width
                     (~ .display ((string<-number args.first 16) .lowercase)))
          (scanning sink s.rest args.rest))
        (else
          (error "Bad format string" (string<-list s)))))

    (to (maybe-pad sink pad sign width message)
      (hm (when width
            ;; TODO fix: we're currently justifying to width, but not truncating
            (let w (if sign (* sign width) width))
            (sink .display ((string<-writer message) .justify w pad)))
          (when sign
            (error "Missing width in format string"))
          (else
            (call sink message))))

    format))
