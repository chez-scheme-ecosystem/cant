;; Write `thing` into a string, but give up and truncate if the length
;; overflows `bound`.
(to (write-to-bounded-string thing bound)
  (string<-writer (for bounded-writer<- ((sink bound))
                    (sink .write thing))))

(to ((bounded-writer<- writer bound) sink)
  (with-ejector
   (on (ejector)
     ;; TODO (- bound 2) leaves space for the possible overflow mark
     ;; ".." -- but it'd be nice to omit the ".." in the case where
     ;; the output just fits. It's sort of annoying to get ".."
     ;; scribbled over a perfectly good end-of-string. We could fix
     ;; this by an extra warning-track state.
     ;; TODO if you do that, consider somehow disambiguating whether
     ;; the output legitimately ends in ".." or whatever
     (let budget (box<- (- bound 2))) ; The length remaining
     (let ss (string-sink<-))

     (to (cut-off)
       (let chunk ss.output-string)
       (let length chunk.count)
       (hm (when (<= length budget.^)
             (sink .display chunk)
             (budget .-= length))
           (else
             (sink .display (chunk .slice 0 budget.^))
             (sink .display "..")
             ss.close
             (ejector .eject void))))

     (writer (make bounded-sink {extending sink-trait}
               (to (~ .display a)   (ss .display a)   (cut-off))
               (to (~ .write-u8 u8) (ss .write-u8 u8) (cut-off))
               (to ~.close          ss.close))))))

(export write-to-bounded-string bounded-writer<-)
